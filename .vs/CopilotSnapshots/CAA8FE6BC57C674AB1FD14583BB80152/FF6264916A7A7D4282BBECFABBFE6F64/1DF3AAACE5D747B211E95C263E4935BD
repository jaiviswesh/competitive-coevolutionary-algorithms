import random
import numpy as np
import multiprocessing
from functools import partial
import traceback
import sys

from deap import base, creator, tools, algorithms
from hunted_sim import HuntedSim, example_config

# --- GA parameters ---
POP_SIZE = 20
NGEN = 50
CXPB = 0.9  # Crossover probability
# Mutation probabilities
MUTPB_PRED = 1.0 / sum([p['count'] for p in example_config()['predators']])
MUTPB_ESC = 1.0 / (len(example_config()['escapers']) * 5)

# --- Predator genome constants ---
PREDATOR_COUNT = sum([p['count'] for p in example_config()['predators']])
PREDATOR_MIN = 2.0
PREDATOR_MAX = 5.0

# --- Escaper genome constants ---
ESCAPER_COUNT = len(example_config()['escapers'])
BORDERS = ['N', 'S', 'E', 'W']
COORD_MIN, COORD_MAX = 0.0, 400.0
SPEED_MIN, SPEED_MAX = 1.0, 5.0
TIME_MIN, TIME_MAX = 0.0, 600.0
AVOID_MIN, AVOID_MAX = 0.0, 2.0

# --- Hall of Fame size ---
HOF_SIZE = 5

# ------------- Safe creator setup -------------
# Avoid re-creating creators if this file is executed multiple times in the same interpreter
if "FitnessMin" not in creator.__dict__:
    creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
if "Predator" not in creator.__dict__:
    creator.create("Predator", list, fitness=creator.FitnessMin)
if "Escaper" not in creator.__dict__:
    creator.create("Escaper", list, fitness=creator.FitnessMin)

# --- Predator individual: list of prox radii ---
def predator_init():
    return [random.uniform(PREDATOR_MIN, PREDATOR_MAX) for _ in range(PREDATOR_COUNT)]

# --- Escaper individual ---
def escaper_init():
    genome = []
    for _ in range(ESCAPER_COUNT):
        border = random.choice(BORDERS)
        coord = random.uniform(COORD_MIN, COORD_MAX)
        speed = random.uniform(SPEED_MIN, SPEED_MAX)
        time = random.uniform(TIME_MIN, TIME_MAX)
        avoidance = random.uniform(AVOID_MIN, AVOID_MAX)
        genome.extend([BORDERS.index(border), coord, speed, time, avoidance])
    return genome

# --- Decode escaper genome into list of dicts for simulator ---
def decode_escaper(genome):
    # If None or empty, return default escapers
    if genome is None or len(genome) == 0:
        return example_config()['escapers']
    escapers = []
    for i in range(0, len(genome), 5):
        try:
            border_idx = int(round(genome[i])) % len(BORDERS)
            border = BORDERS[border_idx]
            coord = float(np.clip(genome[i+1], COORD_MIN, COORD_MAX))
            speed = float(np.clip(genome[i+2], SPEED_MIN, SPEED_MAX))
            time = float(np.clip(genome[i+3], TIME_MIN, TIME_MAX))
            avoidance = float(np.clip(genome[i+4], AVOID_MIN, AVOID_MAX))
        except Exception:
            # Fallback to defaults for a single escaper if decoding fails
            return example_config()['escapers']
        escapers.append({
            'border': border,
            'coord': coord,
            'speed': speed,
            'escape_time': time,
            'avoidance': avoidance
        })
    return escapers

# --- Decode predator genome into config (assign prox_r per swarm) ---
def apply_predator_genome(cfg, pred_genome):
    if pred_genome is None or len(pred_genome) == 0:
        return
    idx = 0
    # assign prox_r sequentially to individuals; here we keep group's prox_r = first individual's value
    for group in cfg['predators']:
        radii = []
        for _ in range(group['count']):
            if idx < len(pred_genome):
                radii.append(float(np.clip(pred_genome[idx], PREDATOR_MIN, PREDATOR_MAX)))
                idx += 1
        if radii:
            group['prox_r'] = radii[0]

# --- Universal Evaluation Function (robust) ---
def evaluate(individual, opponent_genome, individual_type):
    """
    individual_type: 'predator' or 'escaper'
    opponent_genome: genome of the opponent (may be None)
    """
    print(f"\n--> Evaluating {individual_type} starting with {individual[:3]}")
    cfg = example_config()
    # apply genomes to cfg
    try:
        if individual_type == 'predator':
            # individual = predator genome
            apply_predator_genome(cfg, individual)
            cfg['escapers'] = decode_escaper(opponent_genome)
        else:
            # individual is escaper genome
            apply_predator_genome(cfg, opponent_genome)
            cfg['escapers'] = decode_escaper(individual)

        # Run sim with try/except to catch runtime errors inside HuntedSim
        sim = HuntedSim(cfg, seed=random.randint(0, 10000))
        stats, _ = sim.run()
        print(f".", end='', flush=True)

        if individual_type == 'predator':
            return (stats['F'],)
        else:
            return (-stats['F'],)
    except Exception as e:
        # Print traceback for debugging and return a large penalty
        print("ERROR during simulation (type={}):".format(individual_type))
        traceback.print_exc()
        # Return a penalized fitness: large positive for predator (minimize), large negative for escaper (maximize)
        if individual_type == 'predator':
            return (1e9,)
        else:
            return (-1e9,)

    # Predator minimizes F, Escaper wants to maximize F so we return -F (since FitnessMin)

# --- Escaper mutation (custom, handles mix of discrete + floats) ---
def mutate_escaper(individual, indpb=0.1):
    for i in range(0, len(individual), 5):
        if random.random() < indpb:
            individual[i] = random.randrange(0, len(BORDERS))
        if random.random() < indpb:
            individual[i+1] = random.uniform(COORD_MIN, COORD_MAX)
        if random.random() < indpb:
            individual[i+2] = random.uniform(SPEED_MIN, SPEED_MAX)
        if random.random() < indpb:
            individual[i+3] = random.uniform(TIME_MIN, TIME_MAX)
        if random.random() < indpb:
            individual[i+4] = random.uniform(AVOID_MIN, AVOID_MAX)
    return (individual,)

def main():
    # --- Toolbox setup ---
    toolbox_pred = base.Toolbox()
    toolbox_pred.register("individual", tools.initIterate, creator.Predator, predator_init)
    toolbox_pred.register("population", tools.initRepeat, list, toolbox_pred.individual)
    toolbox_pred.register("mate", tools.cxUniform, indpb=0.5)
    toolbox_pred.register("mutate",
                         tools.mutPolynomialBounded,
                         low=PREDATOR_MIN,
                         up=PREDATOR_MAX,
                         eta=20.0,
                         indpb=0.1)
    toolbox_pred.register("select", tools.selTournament, tournsize=3)

    toolbox_esc = base.Toolbox()
    toolbox_esc.register("individual", tools.initIterate, creator.Escaper, escaper_init)
    toolbox_esc.register("population", tools.initRepeat, list, toolbox_esc.individual)
    toolbox_esc.register("mate", tools.cxBlend, alpha=0.5)
    toolbox_esc.register("mutate", mutate_escaper, indpb=0.1)
    toolbox_esc.register("select", tools.selTournament, tournsize=3)

    # --- Create pool inside main (safe on Windows) ---
    pool = multiprocessing.Pool()
    toolbox_pred.register("map", pool.map)
    toolbox_esc.register("map", pool.map)

    pop_pred = toolbox_pred.population(n=POP_SIZE)
    pop_esc = toolbox_esc.population(n=POP_SIZE)
    hof_pred = tools.HallOfFame(HOF_SIZE)
    hof_esc = tools.HallOfFame(HOF_SIZE)

    print("--- Starting Co-evolution ---")
    for gen in range(NGEN):
        # Choose best opponent genome (or None if HOF empty)
        best_esc_genome = list(hof_esc)[0] if len(hof_esc) > 0 else None
        best_pred_genome = list(hof_pred)[0] if len(hof_pred) > 0 else None

        # Evaluate predators vs chosen escaper
        eval_pred_func = partial(evaluate, opponent_genome=best_esc_genome, individual_type='predator')
        fitnesses_pred = toolbox_pred.map(eval_pred_func, pop_pred)
        for ind, fit in zip(pop_pred, fitnesses_pred):
            ind.fitness.values = fit
        hof_pred.update(pop_pred)

        # Evaluate escapers vs chosen predator
        eval_esc_func = partial(evaluate, opponent_genome=best_pred_genome, individual_type='escaper')
        fitnesses_esc = toolbox_esc.map(eval_esc_func, pop_esc)
        for ind, fit in zip(pop_esc, fitnesses_esc):
            ind.fitness.values = fit
        hof_esc.update(pop_esc)

        # Evolve: selection + variation
        offspring_pred = toolbox_pred.select(pop_pred, k=len(pop_pred))
        offspring_pred = algorithms.varAnd(offspring_pred, toolbox_pred, cxpb=CXPB, mutpb=MUTPB_PRED)
        pop_pred[:] = offspring_pred

        offspring_esc = toolbox_esc.select(pop_esc, k=len(pop_esc))
        offspring_esc = algorithms.varAnd(offspring_esc, toolbox_esc, cxpb=CXPB, mutpb=MUTPB_ESC)
        pop_esc[:] = offspring_esc

        # Safe printing: HOF may be empty in early generations
        pred_best = hof_pred[0].fitness.values[0] if len(hof_pred) > 0 else float('nan')
        esc_best = -hof_esc[0].fitness.values[0] if len(hof_esc) > 0 else float('nan')  # negate to show positive F
        print(f"Gen {gen:02d}: Predator Best F: {pred_best:.2f} | Escaper Best F: {esc_best:.2f}")

    print("--- Co-evolution Finished ---")
    if len(hof_pred) > 0:
        print("Best predator genome:", hof_pred[0])
    if len(hof_esc) > 0:
        print("Best escaper genome:", hof_esc[0])

    pool.close()
    pool.join()


if __name__ == "__main__":
    main()
