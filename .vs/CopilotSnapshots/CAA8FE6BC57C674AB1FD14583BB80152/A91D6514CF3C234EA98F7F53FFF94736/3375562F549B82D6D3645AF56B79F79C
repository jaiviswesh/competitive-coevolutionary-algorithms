import random
import numpy as np
import multiprocessing
from functools import partial
import traceback
import sys
import matplotlib.pyplot as plt

from deap import base, creator, tools, algorithms
from hunted_sim import HuntedSim, example_config

# --- GA parameters ---
POP_SIZE = 20
NGEN = 50
CXPB = 0.9  # Crossover probability
# Mutation probabilities
MUTPB_PRED = 1.0 / sum([p['count'] for p in example_config()['predators']])
MUTPB_ESC = 1.0 / (len(example_config()['escapers']) * 5)

# --- Predator genome constants ---
PREDATOR_COUNT = sum([p['count'] for p in example_config()['predators']])
PREDATOR_MIN = 2.0
PREDATOR_MAX = 5.0

# --- Escaper genome constants ---
ESCAPER_COUNT = len(example_config()['escapers'])
BORDERS = ['N', 'S', 'E', 'W']
COORD_MIN, COORD_MAX = 0.0, 400.0
SPEED_MIN, SPEED_MAX = 1.0, 5.0
TIME_MIN, TIME_MAX = 0.0, 600.0
AVOID_MIN, AVOID_MAX = 0.0, 2.0

# --- Hall of Fame size ---
HOF_SIZE = 5

# ------------- Safe creator setup -------------
# Avoid re-creating creators if this file is executed multiple times in the same interpreter
if "FitnessMin" not in creator.__dict__:
    creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
if "Predator" not in creator.__dict__:
    creator.create("Predator", list, fitness=creator.FitnessMin)
if "Escaper" not in creator.__dict__:
    creator.create("Escaper", list, fitness=creator.FitnessMin)

# --- Predator individual: list of prox radii ---
def predator_init():
    return [random.uniform(PREDATOR_MIN, PREDATOR_MAX) for _ in range(PREDATOR_COUNT)]

# --- Escaper individual ---
def escaper_init():
    genome = []
    for _ in range(ESCAPER_COUNT):
        border = random.choice(BORDERS)
        coord = random.uniform(COORD_MIN, COORD_MAX)
        speed = random.uniform(SPEED_MIN, SPEED_MAX)
        time = random.uniform(TIME_MIN, TIME_MAX)
        avoidance = random.uniform(AVOID_MIN, AVOID_MAX)
        genome.extend([BORDERS.index(border), coord, speed, time, avoidance])
    return genome

# --- Decode escaper genome into list of dicts for simulator ---
def decode_escaper(genome):
    # If None or empty, return default escapers
    if genome is None or len(genome) == 0:
        return example_config()['escapers']
    escapers = []
    for i in range(0, len(genome), 5):
        try:
            border_idx = int(round(genome[i])) % len(BORDERS)
            border = BORDERS[border_idx]
            coord = float(np.clip(genome[i+1], COORD_MIN, COORD_MAX))
            speed = float(np.clip(genome[i+2], SPEED_MIN, SPEED_MAX))
            time = float(np.clip(genome[i+3], TIME_MIN, TIME_MAX))
            avoidance = float(np.clip(genome[i+4], AVOID_MIN, AVOID_MAX))
        except Exception:
            # Fallback to defaults for a single escaper if decoding fails
            return example_config()['escapers']
        escapers.append({
            'border': border,
            'coord': coord,
            'speed': speed,
            'escape_time': time,
            'avoidance': avoidance
        })
    return escapers

# --- Decode predator genome into config (assign prox_r per swarm) ---
def apply_predator_genome(cfg, pred_genome):
    if pred_genome is None or len(pred_genome) == 0:
        return
    idx = 0
    # assign prox_r sequentially to individuals; here we keep group's prox_r = first individual's value
    for group in cfg['predators']:
        radii = []
        for _ in range(group['count']):
            if idx < len(pred_genome):
                radii.append(float(np.clip(pred_genome[idx], PREDATOR_MIN, PREDATOR_MAX)))
                idx += 1
        if radii:
            group['prox_r'] = radii[0]

# --- Universal Evaluation Function (robust) ---
def evaluate(individual, opponent_genome, individual_type):
    """
    individual_type: 'predator' or 'escaper'
    opponent_genome: genome of the opponent (may be None)
    """
    print(f"\n--> Evaluating {individual_type} starting with {individual[:3]}")
    cfg = example_config()
    # apply genomes to cfg
    try:
        if individual_type == 'predator':
            # individual = predator genome
            apply_predator_genome(cfg, individual)
            cfg['escapers'] = decode_escaper(opponent_genome)
        else:
            # individual is escaper genome
            apply_predator_genome(cfg, opponent_genome)
            cfg['escapers'] = decode_escaper(individual)

        # Run sim with try/except to catch runtime errors inside HuntedSim
        sim = HuntedSim(cfg, seed=random.randint(0, 10000))
        stats, _ = sim.run()
        print(f".", end='', flush=True)

        if individual_type == 'predator':
            return (stats['F'],)
        else:
            return (-stats['F'],)
    except Exception as e:
        # Print traceback for debugging and return a large penalty
        print("ERROR during simulation (type={}):".format(individual_type))
        traceback.print_exc()
        # Return a penalized fitness: large positive for predator (minimize), large negative for escaper (maximize)
        if individual_type == 'predator':
            return (1e9,)
        else:
            return (-1e9,)

    # Predator minimizes F, Escaper wants to maximize F so we return -F (since FitnessMin)

# --- Escaper mutation (custom, handles mix of discrete + floats) ---
def mutate_escaper(individual, indpb=0.1):
    for i in range(0, len(individual), 5):
        if random.random() < indpb:
            individual[i] = random.randrange(0, len(BORDERS))
        if random.random() < indpb:
            individual[i+1] = random.uniform(COORD_MIN, COORD_MAX)
        if random.random() < indpb:
            individual[i+2] = random.uniform(SPEED_MIN, SPEED_MAX)
        if random.random() < indpb:
            individual[i+3] = random.uniform(TIME_MIN, TIME_MAX)
        if random.random() < indpb:
            individual[i+4] = random.uniform(AVOID_MIN, AVOID_MAX)
    return (individual,)

def init_worker():
    """Initialize worker process to ignore keyboard interrupts"""
    import signal
    signal.signal(signal.SIGINT, signal.SIG_IGN)

def main():
    # --- Toolbox setup ---
    toolbox_pred = base.Toolbox()
    toolbox_pred.register("individual", tools.initIterate, creator.Predator, predator_init)
    toolbox_pred.register("population", tools.initRepeat, list, toolbox_pred.individual)
    toolbox_pred.register("mate", tools.cxUniform, indpb=0.5)
    toolbox_pred.register("mutate",
                         tools.mutPolynomialBounded,
                         low=PREDATOR_MIN,
                         up=PREDATOR_MAX,
                         eta=20.0,
                         indpb=0.1)
    toolbox_pred.register("select", tools.selTournament, tournsize=3)

    toolbox_esc = base.Toolbox()
    toolbox_esc.register("individual", tools.initIterate, creator.Escaper, escaper_init)
    toolbox_esc.register("population", tools.initRepeat, list, toolbox_esc.individual)
    toolbox_esc.register("mate", tools.cxBlend, alpha=0.5)
    toolbox_esc.register("mutate", mutate_escaper, indpb=0.1)
    toolbox_esc.register("select", tools.selTournament, tournsize=3)

    # --- Create pool inside main with interrupt handling ---
    pool = multiprocessing.Pool(initializer=init_worker)
    toolbox_pred.register("map", pool.map)
    toolbox_esc.register("map", pool.map)

    try:
        pop_pred = toolbox_pred.population(n=POP_SIZE)
        pop_esc = toolbox_esc.population(n=POP_SIZE)
        hof_pred = tools.HallOfFame(HOF_SIZE)
        hof_esc = tools.HallOfFame(HOF_SIZE)

        print("\n=== Starting Co-evolution ===")
        print(f"Population size: {POP_SIZE}")
        print(f"Number of generations: {NGEN}")
        print(f"Crossover probability: {CXPB}")
        print(f"Predator mutation probability: {MUTPB_PRED:.4f}")
        print(f"Escaper mutation probability: {MUTPB_ESC:.4f}\n")

        stats_pred = tools.Statistics(lambda ind: ind.fitness.values[0])
        stats_pred.register("min", np.min)
        stats_pred.register("avg", np.mean)

        stats_esc = tools.Statistics(lambda ind: -ind.fitness.values[0])  # Negate for escapers
        stats_esc.register("max", np.max)
        stats_esc.register("avg", np.mean)

        for gen in range(NGEN):
            print(f"\n--- Generation {gen+1}/{NGEN} ---")
            
            # Choose best opponent genome (or None if HOF empty)
            best_esc_genome = list(hof_esc)[0] if len(hof_esc) > 0 else None
            best_pred_genome = list(hof_pred)[0] if len(hof_pred) > 0 else None

            # Evaluate predators vs chosen escaper
            eval_pred_func = partial(evaluate, opponent_genome=best_esc_genome, individual_type='predator')
            fitnesses_pred = toolbox_pred.map(eval_pred_func, pop_pred)
            for ind, fit in zip(pop_pred, fitnesses_pred):
                ind.fitness.values = fit
            hof_pred.update(pop_pred)

            # Get statistics for predators
            pred_stats = stats_pred.compile(pop_pred)
            print(f"Predator Best F: {pred_stats['min']:.2f}, Avg F: {pred_stats['avg']:.2f}")

            # Evaluate escapers vs chosen predator
            eval_esc_func = partial(evaluate, opponent_genome=best_pred_genome, individual_type='escaper')
            fitnesses_esc = toolbox_esc.map(eval_esc_func, pop_esc)
            for ind, fit in zip(pop_esc, fitnesses_esc):
                ind.fitness.values = fit
            hof_esc.update(pop_esc)

            # Get statistics for escapers
            esc_stats = stats_esc.compile(pop_esc)
            print(f"Escaper Best F: {esc_stats['max']:.2f}, Avg F: {esc_stats['avg']:.2f}")

            # Evolve: selection + variation
            offspring_pred = toolbox_pred.select(pop_pred, k=len(pop_pred))
            offspring_pred = algorithms.varAnd(offspring_pred, toolbox_pred, cxpb=CXPB, mutpb=MUTPB_PRED)
            pop_pred[:] = offspring_pred

            offspring_esc = toolbox_esc.select(pop_esc, k=len(pop_esc))
            offspring_esc = algorithms.varAnd(offspring_esc, toolbox_esc, cxpb=CXPB, mutpb=MUTPB_ESC)
            pop_esc[:] = offspring_esc

    except KeyboardInterrupt:
        print("\nEvolution interrupted by user")
    except Exception as e:
        print(f"\nError during evolution: {str(e)}")
        import traceback
        traceback.print_exc()
    finally:
        print("\n=== Co-evolution Summary ===")
        best_pred = None
        best_esc = None
        if len(hof_pred) > 0:
            best_pred = hof_pred[0]
            print("\nBest predator genome:")
            print(f"Fitness: {hof_pred[0].fitness.values[0]:.2f}")
            print(f"Parameters: {hof_pred[0]}")
        if len(hof_esc) > 0:
            best_esc = hof_esc[0]
            print("\nBest escaper genome:")
            print(f"Fitness: {-hof_esc[0].fitness.values[0]:.2f}")  # Negate back for display
            print(f"Parameters: {hof_esc[0]}")

        # Clean shutdown of pool
        pool.close()
        pool.join()

        # --- Plot best simulation ---
        if best_pred is not None and best_esc is not None:
            cfg = example_config()
            apply_predator_genome(cfg, best_pred)
            cfg['escapers'] = decode_escaper(best_esc)
            sim = HuntedSim(cfg, seed=42)
            stats, traj = sim.run(record_trajectories=True)
            print("\nBest simulation stats:", stats)

            plt.figure(figsize=(8, 8))
            # --- Plot Predators (all red) ---
            pred_label_set = False
            for pid, tlist in traj['pred'].items():
                arr = np.array(tlist)
                if arr.shape[0] > 0:
                    label = 'Predator' if not pred_label_set else '_nolegend_'
                    plt.plot(arr[:,0], arr[:,1], color='red', linewidth=0.7, alpha=0.8, label=label)
                    pred_label_set = True
            # --- Plot Escapers (all blue) ---
            esc_label_set = False
            for eid, tlist in traj['esc'].items():
                arr = np.array(tlist)
                if arr.shape[0] > 0:
                    label = 'Escaper' if not esc_label_set else '_nolegend_'
                    plt.plot(arr[:,0], arr[:,1], '--', color='blue', linewidth=1.5, label=label)
                    plt.scatter(arr[0,0], arr[0,1], color='blue', marker='x', s=100, label='_nolegend_')
                    plt.scatter(arr[-1,0], arr[-1,1], color='blue', marker='o', s=80, facecolors='none', edgecolors='blue', label='_nolegend_')
                    esc_label_set = True
            plt.xlim(0, cfg['map_w'])
            plt.ylim(0, cfg['map_h'])
            plt.title('Agent Trajectories (Best Co-evolved)')
            plt.xlabel('X Coordinate')
            plt.ylabel('Y Coordinate')
            plt.grid(True, linestyle=':', alpha=0.6)
            plt.legend(loc='best')
            plt.gca().set_aspect('equal', adjustable='box')
            plt.savefig('best_simulation_plot.png')
            plt.show(block=True)

if __name__ == "__main__":
    main()
